//remove the line numbers, column numbers, folio numbers, and lacuna indicators that contain numbers
document.querySelectorAll(".linenumber").forEach(e => e.remove());
document.querySelectorAll(".lac").forEach(e => e.remove());
document.querySelectorAll(".columnBreak").forEach(e => e.remove());
document.querySelectorAll(".folioBreak").forEach(e => e.remove());

//put supplied text in brackets and solve the issue of line breaks in the middle of words
document.querySelectorAll(".supplied").forEach(e => {e.innerText = "[" + e.innerText + "]"});
document.querySelectorAll(".nobreak").forEach(e => e.innerText = "~~");

//parse the verses and format them for insertion into database
document.querySelectorAll(".msstrans").forEach(e =>{
    let regexed = e.innerText;

    //quit here if there isn't a transcription for the desired page
    if (regexed.match(/No Transcription Available/i)) {return;}

    //if there is a line break in the middle of the word, I previously notated it with ~~, so remove it now
    regexed = regexed.replace(/~~\n/g,'');

    //remove all other line breaks (will be reinserted later)
    regexed = regexed.replace(/\n/g,' ');

    //remove any characters that are not Alphanumeric, brackets, spaces, newlines, colons, or Greek
    regexed = regexed.replace(/[^ςερτυθιοπασδφγηξκλζχψωβνμ\n\[\] :\w]/g,'');

    //remove "inscriptio" and "subscriptio" annoyances
    regexed = regexed.replace(/\d? ?[A-Za-z]+ ?subscriptio/g,'');
    regexed = regexed.replace(/inscriptio\n?/g,'');

    //remove duplicate spaces
    regexed = regexed.replace(/  +/g,' ');

    //remove spaces after verse numbers
    regexed = regexed.replace(/(\d) /g,'$1');

    //put newlines back in at each verse
    regexed = regexed.replace(/(\d? ?[A-Za-z]+ )?(\d+:)?(\d+)/g,'\n$1$2$3, ');

    //remove empty lines
    regexed = regexed.replace(/^\n/g,'');

    //get the book and chapter of the first verse on the page
    let currbook = regexed.match(/\d? ?[A-Za-z]+/)[0].trim();
    let currchap = regexed.match(/\d+:/)[0].replace(/:/,'');

    //sometimes the INTF does not list the first verse, so subtract 1 from the actual first verse
    let firstverse = regexed.match(/:\d+/);
    firstverse = parseInt(firstverse[0].substring(1)) - 1;
    
    //for each verse, append the book and/or chapter to the beginning of the line if necessary
    let firstofpage = true;
    for (let line of regexed.split('\n')) {
        //check to reset currbook
        if (line.match(/^\d? ?[A-Za-z] ?/) && line.match(/:/)) {
            //re-evaluate currbook and currchap (no appending necessary) and remove leading whitespace
            currbook = line.match(/\d? ?[A-Za-z]+/)[0].trim();
            currchap = line.match(/\d+:/)[0].replace(/:/,'');
            line = line.replace(/^ +/,'');
        }
        else {
            //check to reset currchap
            if (line.match(/\d+:\d+/)) {
                //re-evaluate currchap (and append currbook to line)
                currchap = line.match(/\d+:/)[0].replace(/:/,'');
                line = currbook + " " + line;
            }
            else {
                //append book and chapter to line
                line = currbook + " " + currchap + ":" + line;

	        //for that dangling first verse case: add verse if necessary
	        if (!line.match(/:\d/)) {
                    let temp = line.split(':');
                    temp[1] = firstverse + "," + temp[1];
                    line = temp.join(':');
                }
            }
        }

	//remove redundant brackets that used to stop and start around (now removed) newlines
        line = line.replace(/\]\[/g,'');

        //append thing for the first verse of the page
        if (firstofpage && !(currchap == 1 && firstverse == 0)) {
            //may have to concatenate here, but could just concatenate EVERYWHERE and remove this altogether
        }

        firstofpage = false;

        //do not print lines that do not contain actual verse text
        if (!line.match(/:0/)) {
            console.log(line);
        }
    }
});